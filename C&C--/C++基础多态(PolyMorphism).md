C++按照实现的时机分为编译时多态和运行时多态
1.编译时多态也成为静态连编，是指程序在编译的时候就确定了多态性，通过重载机制实现
2运行时多态又称为动态联编，是指必须在运行中才能确定的多态性，通过继承和虚函数实现
##虚函数
若派生类中定义了于基类相同的函数，使用基类指针指向派生类对象时，通过指针调用的是基类函数而不是派生类中的函数。
```
class Animal
{
public:
   void speak()
   {
     cout<<"animal speak"<<endl;
   }
};

class Dog:public Animal
{
public:
    void speak(){
        cout<<"dog speak"<<endl;
    }

};

int main() {
    Dog dog;
    Animal *animal = &dog;
    animal->speak();
    return 0;
}
```
  &emsp;&emsp; animal->speak()会调用的是基类的speak函数，而不会调用Dog类的派生同名函数。编译器的做法不是我们期望的，根据实际的对象类型来判断重写函数的调用，如果父类指针指向的是父类对象则调用父类中定义的函数，如果父类指针指向的是子类对象则调用子类中定义的重写函数。
&emsp;&emsp;那些被virtual关键字修饰的成员函数就是虚函数。虚函数的作用，用专业术语来解释就是实现多态性(Polymorphism），多态性是将接口与实现进行分离；用形象的语言来解释就是实现以共同的方法，但因个体差异而采用不同的策略。同样的调用语句有多种不同的表现形态。
虚函数声明如下：
C++中通过virtual关键字对多态进行支持
使用virtual声明的函数被重写后即可展现多态特性
```
virtual ReturnType FunctionName(Parameter)；
```

虚函数必须实现，如果不实现，编译器将报错，错误提示为
```
error LNK****: unresolved external symbol "public: virtual void __thiscall
ClassName::virtualFunctionName(void)"
```
##纯虚函数
&emsp;&emsp;在很多情况下， 基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。为了解决这个问题，方便使用类的多态性，引入了纯虚函数的概念。　纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”
纯虚函数声明如下：
```
virtual 类型 函数名(参数列表)= 0;
```
## 抽象类
&emsp;&emsp;一个包含纯虚拟函数的类称为抽象类。 抽象类是不能定义对象的。同时抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。

