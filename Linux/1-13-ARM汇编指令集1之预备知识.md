 

指令和伪指令：

* （汇编）指令是CPU机器指令的助记符，经过编译后会得到一串1/0组成的机器码，可以由CPU读取执行。

* （汇编）伪指令本质上不是指令（只是和指令一起写在代码中），它是编译器环境提供的，目的是用来指导编译过程，经过编译后伪指令最终不会生成机器码。

两种不同风格的ARM指令：

* ARM官方的ARM汇编风格：指令一般用大写字母，Windows中IDE开发环境常用（如ADS、MDK等）。eg：LDR r0，[r1]

* GUN风格的ARM汇编：指令一般用小写字母，linux下常用。eg：ldr r0，[r1]

ARM的汇编特点：

1\. LDR/STR架构

* ARM采用RISC架构，CPU本身不能直接读取内存中内容，而需要先将内存中的内容载入CPU内的通用寄存器中才能被CPU处理。

* ldr（load register）指令将内存内容加载到通用寄存器中。

* str（store register）指令将寄存器内容存入内存空间中。

* ldr/str 组合用来实现ARM CPU和内存数据交换。

2\. ARM汇编的8种寻址方式

* 寄存器寻址                               mov r0，r1

* 立即寻址                                   mov r1,#0xFF

* 寄存器移位寻址                        mov r1,r0,lsl#3

* 寄存器间接寻址                        mov r0,[r1]

* 基址变址寻址                            mov r0,[r1,#4]

* 多寄存器寻址                            ldmia r1!,{r2-r7,r12}

* 堆栈寻址                                   stmfd sp!,{r2-r7,lr}

* 相对寻址                                    beq flag

flag:

3.指令后缀

* 同一指令经常附带不同后缀，变成不同的指令。常见的后缀如下：

* B(byte) 功能不变，操作长度变为8位。

* H(Half Word) 功能不变，操作长度变为16位。

* S(signed) 功能不变，操作数变为有符号位。

eg：ldr /ldrb / ldrh /ldrsb /ldrsh

* S(S标志) 功能不变，影响CPSR标志位。eg: mov和movs

4.条件执行后缀

**![image](http://upload-images.jianshu.io/upload_images/143845-f07de5a577934306?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)**

5.多级指令流水线

* 为增加处理器指令流的速度，ARM使用多级流水线。

下图为3级流水线工作原理示意图（S5PV210使用13级流水线，ARM11使用8级）

- 允许多个操作同时处理，而非顺序执行

**![image](http://upload-images.jianshu.io/upload_images/143845-ac2bfb884a0dd7dc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)**

所以可以看到PC指向正在取指的指令，而非正在执行的指令。
